;
; ArthimeticandBooleanexp.asm
;
; Created: 02-02-2023 07:46:14
; Author : Admin
;NOTE COMPARE INSTRUCTION 
; BREQ		BRANCH IF EQUAL				BRANCH IF Z=1 (ZERO FLAG)
; BRNE		BRANCH IF NOT EQUAL			BRANCH IF Z=0 
; BRSH		BRANCH IF SAME OR HIGHER	BRANCH IF C=0 (CARRY FLAG)
; BRLO		BRANCH IF LOWER				BRANCH IF C=1
; BRLT		BRANCH IF LESS THAN(SIGNED)	BRANCH IF S=1 (SIGN FLAG)
; BRGE		BRANCH IF GREATER THAN OR EQUAL BRANCH IF S=0
; BRVS		BRANCH IF OVERFLOW FLAG SET	BRANCH IF V=1(OVERFLOW FLAG)
; BRVC		BRANCH IF OVERFLOW FLAG CLEAT	BRANCH IF V=0
;
;
;
; Replace with your application code
			.EQU VAL_1=27
			.EQU VAL_2=54
			.EQU HEX_NUM = 0X315
			.EQU RMND_L = 0X322
			.EQU RMND_M = 0X323
			.EQU RMND_H = 0X324
			.DEF NUM = R16
			.DEF DENOMINATOR = R17
			.DEF QUOTIENT = R18
			.include "m32def.inc"
			.org 00
			LDI R21, 0XF5
			LDI R22, 0X0B
			ADC R21,R22
			LDI R26, 0X62
			LDI R27, 0X27
			LDI R28,0X96
			LDI R29,0X12
			SUB R26, R28
			SBC R27,R29
			LDI R23, 0X25
			LDI R24,0X65
			MUL R23,R24
;;;NO DIVISION MNEMONIC SO USE THIS PROGRAM;;;;
			LDI NUM, 95
			LDI DENOMINATOR, 10
			CLR QUOTIENT
	L1:		INC QUOTIENT
			SUB NUM,DENOMINATOR
			BRCC L1					; BRANCH IF C IS ZERO

			DEC QUOTIENT
			ADD NUM, DENOMINATOR
			LDI R16,0
			LDI R17,0
			LDI R18,0
;;;;;PROGRAM FOR DATA FROM SENSOR AND CONVERTIT TO DECIMAL AND SAVE LEAST SIGNIFICANT BIT IN LOCATION 0X322
			LDI R25, 0XFD		;$FD = 253 IN DECIMAL
			STS HEX_NUM,R25		;STORE $FD IN LOCATION 0X315

;;;==============================================================
			LDS NUM, HEX_NUM
			LDI DENOMINATOR ,10		;DENOMINATOR = 10

L2:			INC QUOTIENT			;
			SUB NUM, DENOMINATOR 
			BRCC L2
			DEC QUOTIENT			;ONCE TOO MANY
			ADD NUM, DENOMINATOR	;ADD BACK TO IT
			STS RMND_L, NUM

			MOV NUM, QUOTIENT
			LDI QUOTIENT,0

L3:			INC QUOTIENT
			SUB NUM, DENOMINATOR
			BRCC L3

			DEC QUOTIENT
			ADD NUM,DENOMINATOR
			STS RMND_M, NUM

			STS RMND_H, QUOTIENT
	;;;AND POERATION

			LDI R20,0X35
			ANDI R20,0X0F

	;;;;;;oring instrusction to set on pb5 and off pb2
			sbi ddrb,2				;bit 2 of port b is output
			SBI DDRB,5				;BIT 5 OF PORTB IS OUTPUT
			IN R20, PORTB			;MOVE PORTB TO R20,THE VALUE OF PORTB INSTEAD OF PINB BECAUSE WE WANT TO KNOW THE LAST VALUE OF PORTB NOT THE VALUE OF AVR CHIP PINS

			ORI R20, 0B00000100		;SET BIT 2 OF R20 TO ONE
			ANDI R20,0B11011111		;CLEAR BIT 5 OF R20 TO ZERO
			OUT PORTB,R20			;OUT R20 TO PORTB

	;;;EOR ISNTRUCTION
			LDI R20,0X54
			LDI R21,0X78
			EOR R20,R21
	;;;READ AND TEST PORTB TO SEE WHETHER IT HAS THE VALUE 45H, IF IT DOES,SEND 99H PORTC OTHERWISE IT IS CLEARED
	;;; TO COME OUT OF THE LOOP CHANGE PORT B VALUE TO 0X45 DURING SIMULATION MANUALLY
			LDI R20,0XFF			;R20=0XFF
			OUT DDRC,R20			;PORTC IS OUTPUT
			LDI R20,0X00			;R20=0
			OUT DDRB,R20			;PORTB IS INPUT
			OUT PORTC, R20			;PORTC=00
			LDI R21,0X45			;R21=0X45
	HERE:	IN R20,PINB				;GET A BYTE
			EOR R20,R21				;EX-OR WITH 0X45
			BRNE HERE				;BRANCH IF PORTB HAS VALUE OTHER THAN 45
			LDI R20,0X99			;R20=0X99
			OUT PORTC,R20			;PORTC=99H

	;;;COM INSTRUCTION COMPLEMENT

			COM R20					;COMPLEMENT R20 VALUE

	;;;NEG INSTRUCTION NEGATE TAKE 2'S COMPLEMENT OF A REGISTER
			
			NEG R21
	;; PROAGRAM TO MONITOR PORTB CONTINUOUSLY FOR TEH VALUE 63H ITSHOULD STOP MONITORING ONLY IF PORTB = 63H
		;;; TO COME OUT OF THE LOOP CHANGE PORT B VALUE TO 0X63 DURING SIMULATION MANUALLY
			LDI R20,0X00
			OUT DDRB,R20			;PORTB IS INPUT
			LDI R21,0X63
AGAIN:		IN R20,PINB
			CP R20,R21				;COMPARE WITH 0X63, Z=1 IF YES
			BRNE AGAIN				;GO TO AGAIN IF PORTB IS NOT EQUAL TO 0X63
	;;PROGRAM TO FIND THE GREATER OF THE VALUE 27 AND 54 AND PLACE IT IN R20
			
			LDI R20,VAL_1			;R20=VAL_1
			LDI R21,VAL_2			;R21=VAL_2
			CP R21,R20				;COMPARE R21 AND R20
			BRLO TEMP1				;IF R21<R20 (BRANCH IF LOWER) GOTO NEXT
			LDI R20,VAL_2
			LDI R16,0XFF
			OUT DDRB,R16
			LDI R16,0X00
			OUT PORTB,R16			;CLEAR PORTB AND PINB
	;; PORTB IS AN INPUT PORT CONNECTED TO TEMPERATURE SENSOR.
	;;PROGRAM TO READ THE TEMPERATURE AND TEST IT FOOR THE VALUE 75,
	;;ACCORDING THE TEST RESULT OF THE TEMPERATURE VALUE IN TO THE REGISTERS INDICATED BY THE FOLLOWING
	;; IF T =75			THEN R16 =T ;;R17=0;	R18=0
	;; IF T >75			THEN R16 =0 ;;R17=T;	R18=0
	;; IF T <75			THEN R16=0	;;R17=0;	R18=T	
	
TEMP1:		LDI R20,0X00			;R20 =0
			OUT DDRB, R20			;PORTB = INPUT
			
			CLR R16					;R16=0
			CLR R17					;R17=0
			CLR R18					;R18=0
			IN R20,PINB				; PINB TO R20
			CPI R20,75				;COMPARE R20 (PORTB) AND 75
			BRSH SAME_HI
	;;; EXECUTES WHEN R20 <75
			MOV R18,R20
			RJMP P2
	;;;EXECUTES WHEN R20>=75	
SAME_HI:	BRNE HI
	;;EXECUTES WHEN R20=75
			MOV R16, R20
			RJMP P2
	;;EXECUTES WHEN R20>75
HI:			MOV R17,R20	

	;;; PROGRAM TO ADD TWO SIGNED NUMBERS. TEH NUMBERS ARE IN R21 AND R22.
	;;; PROGRAM SHOULD STORE THE RESULT IN R21. 
	;;; IF THE RESULT IS NOT CORRECT THE PROGRAM SHOULD PUT 0XAA ON PORTA AND CLEAR R21

P2:			LDI R21,0XFA		;R21 =0XFA
			LDI R22,0X05		;R22=0X05
			LDI R23,0XFF		;R23 =0XFF
			OUT DDRA, R23		;PORTA IS OUTPUT
			ADD R21,R22			;R21 =R21+R22
			BRVC P3			;IF V=0 (NO ERROR) THEN GO TO NEXT
			LDI R23,0XAA		;R23 =0XAA
			OUT PORTA, R23		;SEND 0XAA TO PORTA
			LDI R21,0X00		;CLEAR R21
;;; ROR RD   INSTRUCTION ROTATE RIGHT THROUGH CARRY 
			
P3:			CLC					;MAKE C = 0 (CARRY IS 0)
			LDI R20,0X26		;R20 = 0010 0110
			ROR R20				;R20 = 0001 1011 C=0
			ROR R20				;R20 = 0000 1101 C=1
			ROR R20				;R20 = 1000 0100 C=1

	;;; ROL RD INSTRUCTION ROTATE LEFT THROUGH C 
			SEC					;MAKE C=1
			LDI R21, 0X15		;C = 1, R21 = 0001 0101
			ROL R21 			;C= 0 , R21 = 0010 1011 
			ROL R21				;C= 0 , R21 = 0101 0110
			ROL R21				;C= 0 , R21 = 1010 1100
			ROL R21				;C= 1 , R21 = 0101 1000
			
	;;;PROGRAM TO TRANSFER THE 41H SERIALLY (ONE BIT AT A TIME)
	;; VIA PIN PB1. PUT ONE HIGH AT THET STARTAND END OF THE DATA.SEND THE LSB FIRST
			
			SBI DDRB, 1			;BIT 1 OF PORT B IS  OUTPUT 
			LDI R20, 0X41		;R20 = THE VALUE TO BE SENT

			CLC					; CLEAR CARRY FLAG
			LDI R16,8			; R16 = 8
			SBI PORTB,1			;BIT 1 OF PORTB IS 1
A1:			ROR R20				;ROTATE RIGHT R20 (SEND LSB TO C FLAG)
			BRCS ONE			;IFC=1 THEN GO TO ONE
			JMP NEXT			;GOTO NEXT
ONE:		SBI PORTB,1			;BIT OF PORTB IS SET TO ONE
NEXT:		CBI PORTB,1			;CLEAR BIT FOR 0 BIT
			DEC R16				;DECREMENT R16
			BRNE A1			;IF R16 IS NOTZERO THEN GO TO AGAIN
			SBI PORTB,1			;BIT 1 OF PORTB IS SET TO ONE
	
	;;; PROGRAM TO BRING IN ABYTE OF DATA SERIALLY VIA PC7 AND SAVE IT IN R21 REGISTER THE BYTE COMES IN WITH LSB FIRST

			CBI DDRC, 7			; BIT 7 OF PORTC IS INPUT
			LDI R16,8			;R16 = 8
			LDI R21,0			;R21 = 0
A2:			SBIC PINC,7			;SKIP THE NEXT LINE IF BIT 7 OF PORTC IS 0
			SEC					;SET CARYY FLAG TO ONE
			SBIS PINC,7			;SKIP THE NEXT LINE IF BIT 7 OF PORT C IS SET
			CLC					;CLEAR CARYY FLAG TO ZERO
			ROR R21				;ROTATE RIGHT R20 MOVE C FLAG TO MSB 
			DEC R16				;DECREMENT R16
			BRNE A2
	;; PROGRAM TO FIND THE THE NUMBER OF 1S IN A GIVEN BYTE

			LDI R23,0X97
			LDI R29,0			;NUMBER OF 1S
			LDI R16,8			;NUMBER OF  BITS IN  A BYTE
A3:			ROR R23				;ROTATE RIGHT R23 AND MOVE LSB TO C FLAG
			BRCC N1				;IF C=0 THE GO TO NEXT
			INC R29				;INCREMENT R29
N1:			DEC R16				;DEC R16
			BRNE A3
			ROR R23				;ONE MORE TIME TO LEAVE R23 UNCHANGED 
	;;; lsl rd instruction logical shift left 

			clc 
			ldi r20,0x26		;R20=0010 0110(38) C=0
			LSL R20				;R20=0100 1100(76) C=0
			LSL R20				;R20=1001 1000(152)C=0
			LSL R20				;R20=0011 0000(48) C=1

	;;;LSR RD LOGICAL SHIFT RIGHT
			
			LDI R20,0X26		;R20 = 0010 0110(38)
			LSR R20				;R20=  0001 0011(19) C=0
			LSR R20				;R20 = 0000 1001(9)  C=1
			LSR R20				;R20 = 0000 0100(4)  C=1
	
	;;;ASR RD ARITHMETIC SHIFT RIGHT WHERE MSB REMAINS SAME BUT IT COPIES TO D6,D5 AND SO ON
			LDI R20,0XD0		;R20 = 1101 0000(-48) C=0
			ASR	R20				;R20 = 1110 1000(-24) C=0
			ASR R20				;R20 = 1111 0100(-12) C=0
			ASR R20				;R20 = 1111 1010(-6)  C=0
			ASR R20				;R20 = 1111 1101(-3)  C=0
			ASR R20				;R20 = 1111 1110(-1)  C=1

	;;;SWAP RD		SWAP TEH LOWER NIBBLE AND G=HIGHER NIBBLE
			LDI R20,0X72
			SWAP R20

	HERE1:	RJMP HERE1

